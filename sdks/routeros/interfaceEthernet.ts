// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class InterfaceEthernet extends pulumi.CustomResource {
    /**
     * Get an existing InterfaceEthernet resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: InterfaceEthernetState, opts?: pulumi.CustomResourceOptions): InterfaceEthernet {
        return new InterfaceEthernet(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'routeros:index/interfaceEthernet:InterfaceEthernet';

    /**
     * Returns true if the given object is an instance of InterfaceEthernet.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is InterfaceEthernet {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === InterfaceEthernet.__pulumiType;
    }

    /**
     * <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
     */
    public readonly ___id_!: pulumi.Output<number | undefined>;
    /**
     * <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
     */
    public readonly ___path_!: pulumi.Output<string | undefined>;
    /**
     * <em>A set of transformations for field names. This is an internal service field, setting a value is not required.</em>
     */
    public readonly ___skip_!: pulumi.Output<string | undefined>;
    /**
     * Advertised speed and duplex modes for Ethernet interfaces over twisted pair, only applies when auto-negotiation is
     * enabled. Advertising higher speeds than the actual interface supported speed will have no effect, multiple options are
     * allowed.
     */
    public readonly advertise!: pulumi.Output<string | undefined>;
    /**
     * Address Resolution Protocol mode: * disabled - the interface will not use ARP * enabled - the interface will use ARP *
     * local-proxy-arp - the router performs proxy ARP on the interface and sends replies to the same interface * proxy-arp -
     * the router performs proxy ARP on the interface and sends replies to other interfaces * reply-only - the interface will
     * only reply to requests originated from matching IP address/MAC address combinations which are entered as static entries
     * in the ARP table. No dynamic entries will be automatically stored in the ARP table. Therefore for communications to be
     * successful, a valid static entry must already exist.
     */
    public readonly arp!: pulumi.Output<string | undefined>;
    /**
     * ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to
     * the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,
     * minutes, hours or days. If no postfix is set then seconds (s) is used.
     */
    public readonly arpTimeout!: pulumi.Output<string | undefined>;
    /**
     * When enabled, the interface "advertises" its maximum capabilities to achieve the best connection possible. Note1:
     * Auto-negotiation should not be disabled on one end only, otherwise Ethernet Interfaces may not work properly. Note2:
     * Gigabit Ethernet and NBASE-T Ethernet links cannot work with auto-negotiation disabled.
     */
    public readonly autoNegotiation!: pulumi.Output<boolean | undefined>;
    /**
     * Sets max rx/tx bandwidth in kbps that will be handled by an interface. TX limit is supported on all Atheros switch-chip
     * ports. RX limit is supported only on Atheros8327/QCA8337 switch-chip ports.
     */
    public readonly bandwidth!: pulumi.Output<string | undefined>;
    /**
     * Changes the cable length setting (only applicable to NS DP83815/6 cards)
     */
    public readonly cableSettings!: pulumi.Output<string | undefined>;
    /**
     * When auto mode is selected, the port that was first connected will establish the link. In case this link fails, the
     * other port will try to establish a new link. If both ports are connected at the same time (e.g. after reboot), the
     * priority will be the SFP/SFP+ port. When sfp mode is selected, the interface will only work through SFP/SFP+ cage. When
     * copper mode is selected, the interface will only work through RJ45 Ethernet port.
     */
    public readonly comboMode!: pulumi.Output<string | undefined>;
    public readonly comment!: pulumi.Output<string | undefined>;
    /**
     * The default name for an interface.
     */
    public /*out*/ readonly defaultName!: pulumi.Output<string>;
    /**
     * Disable running check. If this value is set to 'no', the router automatically detects whether the NIC is connected with
     * a device in the network or not. Default value is 'yes' because older NICs do not support it. (only applicable to x86)
     */
    public readonly disableRunningCheck!: pulumi.Output<boolean | undefined>;
    public readonly disabled!: pulumi.Output<boolean | undefined>;
    /**
     * The factory name of the identifier, serves as resource identifier. Determines which interface will be updated.
     */
    public readonly factoryName!: pulumi.Output<string>;
    /**
     * Changes Forward Error Correction (FEC) mode for SFP28, QSFP+ and QSFP28 interfaces. Same mode should be used on both
     * link ends, otherwise FEC mismatch could result in non-working link or even false link-ups.
     */
    public readonly fecMode!: pulumi.Output<string | undefined>;
    /**
     * Defines whether the transmission of data appears in two directions simultaneously, only applies when auto-negotiation is
     * disabled.
     */
    public readonly fullDuplex!: pulumi.Output<boolean | undefined>;
    public readonly interfaceEthernetId!: pulumi.Output<string>;
    /**
     * Layer2 Maximum transmission unit. [See](https://wiki.mikrotik.com/wiki/Maximum_Transmission_Unit_on_RouterBoards).
     */
    public readonly l2mtu!: pulumi.Output<number | undefined>;
    public readonly loopProtect!: pulumi.Output<string | undefined>;
    public readonly loopProtectDisableTime!: pulumi.Output<string | undefined>;
    public readonly loopProtectSendInterval!: pulumi.Output<string | undefined>;
    public /*out*/ readonly loopProtectStatus!: pulumi.Output<string>;
    /**
     * Media Access Control number of an interface.
     */
    public readonly macAddress!: pulumi.Output<string | undefined>;
    /**
     * Whether the MDI/X auto cross over cable correction feature is enabled for the port (Hardware specific, e.g. ether1 on
     * RB500 can be set to yes/no. Fixed to 'yes' on other hardware.)
     */
    public readonly mdixEnable!: pulumi.Output<boolean | undefined>;
    /**
     * Layer3 Maximum transmission unit
     */
    public readonly mtu!: pulumi.Output<number | undefined>;
    /**
     * Name of the ethernet interface.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Original Media Access Control number of an interface. (read only)
     */
    public /*out*/ readonly origMacAddress!: pulumi.Output<string>;
    /**
     * An option that enables LLDP for managing devices.
     */
    public readonly poeLldpEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * PoE settings: (https://wiki.mikrotik.com/wiki/Manual:PoE-Out)
     */
    public readonly poeOut!: pulumi.Output<string | undefined>;
    /**
     * PoE settings: (https://wiki.mikrotik.com/wiki/Manual:PoE-Out)
     */
    public readonly poePriority!: pulumi.Output<number | undefined>;
    /**
     * An option that allows us to manually control the voltage outputs on the PoE port.
     */
    public readonly poeVoltage!: pulumi.Output<string | undefined>;
    /**
     * An options that disables PoE-Out power for 5s between the specified intervals.
     */
    public readonly powerCycleInterval!: pulumi.Output<string | undefined>;
    /**
     * An address to monitor.
     */
    public readonly powerCyclePingAddress!: pulumi.Output<string | undefined>;
    /**
     * An option that enables ping watchdog of power cycles on the port if a host does not respond to ICMP or MAC-Telnet
     * packets.
     */
    public readonly powerCyclePingEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * If the host does not respond over the specified period, the PoE-Out port is switched off for 5s.
     */
    public readonly powerCyclePingTimeout!: pulumi.Output<string | undefined>;
    /**
     * Whether interface is running. Note that some interface does not have running check and they are always reported as
     * "running"
     */
    public /*out*/ readonly running!: pulumi.Output<boolean>;
    /**
     * When set to on, the port will process received pause frames and suspend transmission if required. auto is the same as on
     * except when auto-negotiation=yes flow control status is resolved by taking into account what other end advertises.
     */
    public readonly rxFlowControl!: pulumi.Output<string | undefined>;
    /**
     * An option to ignore RX LOS (Loss of Signal) status of the SFP module.
     */
    public readonly sfpIgnoreRxLos!: pulumi.Output<boolean | undefined>;
    /**
     * Allows to control rate select pin for SFP ports. Values: high | low
     */
    public readonly sfpRateSelect!: pulumi.Output<string | undefined>;
    /**
     * The temperature in Celsius at which the interface will be temporarily turned off due to too high detected SFP module
     * temperature (introduced v6.48).The default value for SFP/SFP+/SFP28 interfaces is 95, and for QSFP+/QSFP28 interfaces 80
     * (introduced v7.6).
     */
    public readonly sfpShutdownTemperature!: pulumi.Output<number | undefined>;
    /**
     * Whether interface is configured as a slave of another interface (for example Bonding)
     */
    public /*out*/ readonly slave!: pulumi.Output<boolean>;
    /**
     * Sets interface data transmission speed which takes effect only when ```auto_negotiation``` is disabled.
     */
    public readonly speed!: pulumi.Output<string | undefined>;
    /**
     * ID to which switch chip interface belongs to.
     */
    public /*out*/ readonly switch!: pulumi.Output<string>;
    /**
     * When set to on, the port will generate pause frames to the upstream device to temporarily stop the packet transmission.
     * Pause frames are only generated when some routers output interface is congested and packets cannot be transmitted
     * anymore. Auto is the same as on except when auto-negotiation=yes flow control status is resolved by taking into account
     * what other end advertises.
     */
    public readonly txFlowControl!: pulumi.Output<string | undefined>;

    /**
     * Create a InterfaceEthernet resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: InterfaceEthernetArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: InterfaceEthernetArgs | InterfaceEthernetState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as InterfaceEthernetState | undefined;
            resourceInputs["___id_"] = state ? state.___id_ : undefined;
            resourceInputs["___path_"] = state ? state.___path_ : undefined;
            resourceInputs["___skip_"] = state ? state.___skip_ : undefined;
            resourceInputs["advertise"] = state ? state.advertise : undefined;
            resourceInputs["arp"] = state ? state.arp : undefined;
            resourceInputs["arpTimeout"] = state ? state.arpTimeout : undefined;
            resourceInputs["autoNegotiation"] = state ? state.autoNegotiation : undefined;
            resourceInputs["bandwidth"] = state ? state.bandwidth : undefined;
            resourceInputs["cableSettings"] = state ? state.cableSettings : undefined;
            resourceInputs["comboMode"] = state ? state.comboMode : undefined;
            resourceInputs["comment"] = state ? state.comment : undefined;
            resourceInputs["defaultName"] = state ? state.defaultName : undefined;
            resourceInputs["disableRunningCheck"] = state ? state.disableRunningCheck : undefined;
            resourceInputs["disabled"] = state ? state.disabled : undefined;
            resourceInputs["factoryName"] = state ? state.factoryName : undefined;
            resourceInputs["fecMode"] = state ? state.fecMode : undefined;
            resourceInputs["fullDuplex"] = state ? state.fullDuplex : undefined;
            resourceInputs["interfaceEthernetId"] = state ? state.interfaceEthernetId : undefined;
            resourceInputs["l2mtu"] = state ? state.l2mtu : undefined;
            resourceInputs["loopProtect"] = state ? state.loopProtect : undefined;
            resourceInputs["loopProtectDisableTime"] = state ? state.loopProtectDisableTime : undefined;
            resourceInputs["loopProtectSendInterval"] = state ? state.loopProtectSendInterval : undefined;
            resourceInputs["loopProtectStatus"] = state ? state.loopProtectStatus : undefined;
            resourceInputs["macAddress"] = state ? state.macAddress : undefined;
            resourceInputs["mdixEnable"] = state ? state.mdixEnable : undefined;
            resourceInputs["mtu"] = state ? state.mtu : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["origMacAddress"] = state ? state.origMacAddress : undefined;
            resourceInputs["poeLldpEnabled"] = state ? state.poeLldpEnabled : undefined;
            resourceInputs["poeOut"] = state ? state.poeOut : undefined;
            resourceInputs["poePriority"] = state ? state.poePriority : undefined;
            resourceInputs["poeVoltage"] = state ? state.poeVoltage : undefined;
            resourceInputs["powerCycleInterval"] = state ? state.powerCycleInterval : undefined;
            resourceInputs["powerCyclePingAddress"] = state ? state.powerCyclePingAddress : undefined;
            resourceInputs["powerCyclePingEnabled"] = state ? state.powerCyclePingEnabled : undefined;
            resourceInputs["powerCyclePingTimeout"] = state ? state.powerCyclePingTimeout : undefined;
            resourceInputs["running"] = state ? state.running : undefined;
            resourceInputs["rxFlowControl"] = state ? state.rxFlowControl : undefined;
            resourceInputs["sfpIgnoreRxLos"] = state ? state.sfpIgnoreRxLos : undefined;
            resourceInputs["sfpRateSelect"] = state ? state.sfpRateSelect : undefined;
            resourceInputs["sfpShutdownTemperature"] = state ? state.sfpShutdownTemperature : undefined;
            resourceInputs["slave"] = state ? state.slave : undefined;
            resourceInputs["speed"] = state ? state.speed : undefined;
            resourceInputs["switch"] = state ? state.switch : undefined;
            resourceInputs["txFlowControl"] = state ? state.txFlowControl : undefined;
        } else {
            const args = argsOrState as InterfaceEthernetArgs | undefined;
            if ((!args || args.factoryName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'factoryName'");
            }
            resourceInputs["___id_"] = args ? args.___id_ : undefined;
            resourceInputs["___path_"] = args ? args.___path_ : undefined;
            resourceInputs["___skip_"] = args ? args.___skip_ : undefined;
            resourceInputs["advertise"] = args ? args.advertise : undefined;
            resourceInputs["arp"] = args ? args.arp : undefined;
            resourceInputs["arpTimeout"] = args ? args.arpTimeout : undefined;
            resourceInputs["autoNegotiation"] = args ? args.autoNegotiation : undefined;
            resourceInputs["bandwidth"] = args ? args.bandwidth : undefined;
            resourceInputs["cableSettings"] = args ? args.cableSettings : undefined;
            resourceInputs["comboMode"] = args ? args.comboMode : undefined;
            resourceInputs["comment"] = args ? args.comment : undefined;
            resourceInputs["disableRunningCheck"] = args ? args.disableRunningCheck : undefined;
            resourceInputs["disabled"] = args ? args.disabled : undefined;
            resourceInputs["factoryName"] = args ? args.factoryName : undefined;
            resourceInputs["fecMode"] = args ? args.fecMode : undefined;
            resourceInputs["fullDuplex"] = args ? args.fullDuplex : undefined;
            resourceInputs["interfaceEthernetId"] = args ? args.interfaceEthernetId : undefined;
            resourceInputs["l2mtu"] = args ? args.l2mtu : undefined;
            resourceInputs["loopProtect"] = args ? args.loopProtect : undefined;
            resourceInputs["loopProtectDisableTime"] = args ? args.loopProtectDisableTime : undefined;
            resourceInputs["loopProtectSendInterval"] = args ? args.loopProtectSendInterval : undefined;
            resourceInputs["macAddress"] = args ? args.macAddress : undefined;
            resourceInputs["mdixEnable"] = args ? args.mdixEnable : undefined;
            resourceInputs["mtu"] = args ? args.mtu : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["poeLldpEnabled"] = args ? args.poeLldpEnabled : undefined;
            resourceInputs["poeOut"] = args ? args.poeOut : undefined;
            resourceInputs["poePriority"] = args ? args.poePriority : undefined;
            resourceInputs["poeVoltage"] = args ? args.poeVoltage : undefined;
            resourceInputs["powerCycleInterval"] = args ? args.powerCycleInterval : undefined;
            resourceInputs["powerCyclePingAddress"] = args ? args.powerCyclePingAddress : undefined;
            resourceInputs["powerCyclePingEnabled"] = args ? args.powerCyclePingEnabled : undefined;
            resourceInputs["powerCyclePingTimeout"] = args ? args.powerCyclePingTimeout : undefined;
            resourceInputs["rxFlowControl"] = args ? args.rxFlowControl : undefined;
            resourceInputs["sfpIgnoreRxLos"] = args ? args.sfpIgnoreRxLos : undefined;
            resourceInputs["sfpRateSelect"] = args ? args.sfpRateSelect : undefined;
            resourceInputs["sfpShutdownTemperature"] = args ? args.sfpShutdownTemperature : undefined;
            resourceInputs["speed"] = args ? args.speed : undefined;
            resourceInputs["txFlowControl"] = args ? args.txFlowControl : undefined;
            resourceInputs["defaultName"] = undefined /*out*/;
            resourceInputs["loopProtectStatus"] = undefined /*out*/;
            resourceInputs["origMacAddress"] = undefined /*out*/;
            resourceInputs["running"] = undefined /*out*/;
            resourceInputs["slave"] = undefined /*out*/;
            resourceInputs["switch"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(InterfaceEthernet.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering InterfaceEthernet resources.
 */
export interface InterfaceEthernetState {
    /**
     * <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
     */
    ___id_?: pulumi.Input<number>;
    /**
     * <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
     */
    ___path_?: pulumi.Input<string>;
    /**
     * <em>A set of transformations for field names. This is an internal service field, setting a value is not required.</em>
     */
    ___skip_?: pulumi.Input<string>;
    /**
     * Advertised speed and duplex modes for Ethernet interfaces over twisted pair, only applies when auto-negotiation is
     * enabled. Advertising higher speeds than the actual interface supported speed will have no effect, multiple options are
     * allowed.
     */
    advertise?: pulumi.Input<string>;
    /**
     * Address Resolution Protocol mode: * disabled - the interface will not use ARP * enabled - the interface will use ARP *
     * local-proxy-arp - the router performs proxy ARP on the interface and sends replies to the same interface * proxy-arp -
     * the router performs proxy ARP on the interface and sends replies to other interfaces * reply-only - the interface will
     * only reply to requests originated from matching IP address/MAC address combinations which are entered as static entries
     * in the ARP table. No dynamic entries will be automatically stored in the ARP table. Therefore for communications to be
     * successful, a valid static entry must already exist.
     */
    arp?: pulumi.Input<string>;
    /**
     * ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to
     * the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,
     * minutes, hours or days. If no postfix is set then seconds (s) is used.
     */
    arpTimeout?: pulumi.Input<string>;
    /**
     * When enabled, the interface "advertises" its maximum capabilities to achieve the best connection possible. Note1:
     * Auto-negotiation should not be disabled on one end only, otherwise Ethernet Interfaces may not work properly. Note2:
     * Gigabit Ethernet and NBASE-T Ethernet links cannot work with auto-negotiation disabled.
     */
    autoNegotiation?: pulumi.Input<boolean>;
    /**
     * Sets max rx/tx bandwidth in kbps that will be handled by an interface. TX limit is supported on all Atheros switch-chip
     * ports. RX limit is supported only on Atheros8327/QCA8337 switch-chip ports.
     */
    bandwidth?: pulumi.Input<string>;
    /**
     * Changes the cable length setting (only applicable to NS DP83815/6 cards)
     */
    cableSettings?: pulumi.Input<string>;
    /**
     * When auto mode is selected, the port that was first connected will establish the link. In case this link fails, the
     * other port will try to establish a new link. If both ports are connected at the same time (e.g. after reboot), the
     * priority will be the SFP/SFP+ port. When sfp mode is selected, the interface will only work through SFP/SFP+ cage. When
     * copper mode is selected, the interface will only work through RJ45 Ethernet port.
     */
    comboMode?: pulumi.Input<string>;
    comment?: pulumi.Input<string>;
    /**
     * The default name for an interface.
     */
    defaultName?: pulumi.Input<string>;
    /**
     * Disable running check. If this value is set to 'no', the router automatically detects whether the NIC is connected with
     * a device in the network or not. Default value is 'yes' because older NICs do not support it. (only applicable to x86)
     */
    disableRunningCheck?: pulumi.Input<boolean>;
    disabled?: pulumi.Input<boolean>;
    /**
     * The factory name of the identifier, serves as resource identifier. Determines which interface will be updated.
     */
    factoryName?: pulumi.Input<string>;
    /**
     * Changes Forward Error Correction (FEC) mode for SFP28, QSFP+ and QSFP28 interfaces. Same mode should be used on both
     * link ends, otherwise FEC mismatch could result in non-working link or even false link-ups.
     */
    fecMode?: pulumi.Input<string>;
    /**
     * Defines whether the transmission of data appears in two directions simultaneously, only applies when auto-negotiation is
     * disabled.
     */
    fullDuplex?: pulumi.Input<boolean>;
    interfaceEthernetId?: pulumi.Input<string>;
    /**
     * Layer2 Maximum transmission unit. [See](https://wiki.mikrotik.com/wiki/Maximum_Transmission_Unit_on_RouterBoards).
     */
    l2mtu?: pulumi.Input<number>;
    loopProtect?: pulumi.Input<string>;
    loopProtectDisableTime?: pulumi.Input<string>;
    loopProtectSendInterval?: pulumi.Input<string>;
    loopProtectStatus?: pulumi.Input<string>;
    /**
     * Media Access Control number of an interface.
     */
    macAddress?: pulumi.Input<string>;
    /**
     * Whether the MDI/X auto cross over cable correction feature is enabled for the port (Hardware specific, e.g. ether1 on
     * RB500 can be set to yes/no. Fixed to 'yes' on other hardware.)
     */
    mdixEnable?: pulumi.Input<boolean>;
    /**
     * Layer3 Maximum transmission unit
     */
    mtu?: pulumi.Input<number>;
    /**
     * Name of the ethernet interface.
     */
    name?: pulumi.Input<string>;
    /**
     * Original Media Access Control number of an interface. (read only)
     */
    origMacAddress?: pulumi.Input<string>;
    /**
     * An option that enables LLDP for managing devices.
     */
    poeLldpEnabled?: pulumi.Input<boolean>;
    /**
     * PoE settings: (https://wiki.mikrotik.com/wiki/Manual:PoE-Out)
     */
    poeOut?: pulumi.Input<string>;
    /**
     * PoE settings: (https://wiki.mikrotik.com/wiki/Manual:PoE-Out)
     */
    poePriority?: pulumi.Input<number>;
    /**
     * An option that allows us to manually control the voltage outputs on the PoE port.
     */
    poeVoltage?: pulumi.Input<string>;
    /**
     * An options that disables PoE-Out power for 5s between the specified intervals.
     */
    powerCycleInterval?: pulumi.Input<string>;
    /**
     * An address to monitor.
     */
    powerCyclePingAddress?: pulumi.Input<string>;
    /**
     * An option that enables ping watchdog of power cycles on the port if a host does not respond to ICMP or MAC-Telnet
     * packets.
     */
    powerCyclePingEnabled?: pulumi.Input<boolean>;
    /**
     * If the host does not respond over the specified period, the PoE-Out port is switched off for 5s.
     */
    powerCyclePingTimeout?: pulumi.Input<string>;
    /**
     * Whether interface is running. Note that some interface does not have running check and they are always reported as
     * "running"
     */
    running?: pulumi.Input<boolean>;
    /**
     * When set to on, the port will process received pause frames and suspend transmission if required. auto is the same as on
     * except when auto-negotiation=yes flow control status is resolved by taking into account what other end advertises.
     */
    rxFlowControl?: pulumi.Input<string>;
    /**
     * An option to ignore RX LOS (Loss of Signal) status of the SFP module.
     */
    sfpIgnoreRxLos?: pulumi.Input<boolean>;
    /**
     * Allows to control rate select pin for SFP ports. Values: high | low
     */
    sfpRateSelect?: pulumi.Input<string>;
    /**
     * The temperature in Celsius at which the interface will be temporarily turned off due to too high detected SFP module
     * temperature (introduced v6.48).The default value for SFP/SFP+/SFP28 interfaces is 95, and for QSFP+/QSFP28 interfaces 80
     * (introduced v7.6).
     */
    sfpShutdownTemperature?: pulumi.Input<number>;
    /**
     * Whether interface is configured as a slave of another interface (for example Bonding)
     */
    slave?: pulumi.Input<boolean>;
    /**
     * Sets interface data transmission speed which takes effect only when ```auto_negotiation``` is disabled.
     */
    speed?: pulumi.Input<string>;
    /**
     * ID to which switch chip interface belongs to.
     */
    switch?: pulumi.Input<string>;
    /**
     * When set to on, the port will generate pause frames to the upstream device to temporarily stop the packet transmission.
     * Pause frames are only generated when some routers output interface is congested and packets cannot be transmitted
     * anymore. Auto is the same as on except when auto-negotiation=yes flow control status is resolved by taking into account
     * what other end advertises.
     */
    txFlowControl?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a InterfaceEthernet resource.
 */
export interface InterfaceEthernetArgs {
    /**
     * <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
     */
    ___id_?: pulumi.Input<number>;
    /**
     * <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
     */
    ___path_?: pulumi.Input<string>;
    /**
     * <em>A set of transformations for field names. This is an internal service field, setting a value is not required.</em>
     */
    ___skip_?: pulumi.Input<string>;
    /**
     * Advertised speed and duplex modes for Ethernet interfaces over twisted pair, only applies when auto-negotiation is
     * enabled. Advertising higher speeds than the actual interface supported speed will have no effect, multiple options are
     * allowed.
     */
    advertise?: pulumi.Input<string>;
    /**
     * Address Resolution Protocol mode: * disabled - the interface will not use ARP * enabled - the interface will use ARP *
     * local-proxy-arp - the router performs proxy ARP on the interface and sends replies to the same interface * proxy-arp -
     * the router performs proxy ARP on the interface and sends replies to other interfaces * reply-only - the interface will
     * only reply to requests originated from matching IP address/MAC address combinations which are entered as static entries
     * in the ARP table. No dynamic entries will be automatically stored in the ARP table. Therefore for communications to be
     * successful, a valid static entry must already exist.
     */
    arp?: pulumi.Input<string>;
    /**
     * ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to
     * the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,
     * minutes, hours or days. If no postfix is set then seconds (s) is used.
     */
    arpTimeout?: pulumi.Input<string>;
    /**
     * When enabled, the interface "advertises" its maximum capabilities to achieve the best connection possible. Note1:
     * Auto-negotiation should not be disabled on one end only, otherwise Ethernet Interfaces may not work properly. Note2:
     * Gigabit Ethernet and NBASE-T Ethernet links cannot work with auto-negotiation disabled.
     */
    autoNegotiation?: pulumi.Input<boolean>;
    /**
     * Sets max rx/tx bandwidth in kbps that will be handled by an interface. TX limit is supported on all Atheros switch-chip
     * ports. RX limit is supported only on Atheros8327/QCA8337 switch-chip ports.
     */
    bandwidth?: pulumi.Input<string>;
    /**
     * Changes the cable length setting (only applicable to NS DP83815/6 cards)
     */
    cableSettings?: pulumi.Input<string>;
    /**
     * When auto mode is selected, the port that was first connected will establish the link. In case this link fails, the
     * other port will try to establish a new link. If both ports are connected at the same time (e.g. after reboot), the
     * priority will be the SFP/SFP+ port. When sfp mode is selected, the interface will only work through SFP/SFP+ cage. When
     * copper mode is selected, the interface will only work through RJ45 Ethernet port.
     */
    comboMode?: pulumi.Input<string>;
    comment?: pulumi.Input<string>;
    /**
     * Disable running check. If this value is set to 'no', the router automatically detects whether the NIC is connected with
     * a device in the network or not. Default value is 'yes' because older NICs do not support it. (only applicable to x86)
     */
    disableRunningCheck?: pulumi.Input<boolean>;
    disabled?: pulumi.Input<boolean>;
    /**
     * The factory name of the identifier, serves as resource identifier. Determines which interface will be updated.
     */
    factoryName: pulumi.Input<string>;
    /**
     * Changes Forward Error Correction (FEC) mode for SFP28, QSFP+ and QSFP28 interfaces. Same mode should be used on both
     * link ends, otherwise FEC mismatch could result in non-working link or even false link-ups.
     */
    fecMode?: pulumi.Input<string>;
    /**
     * Defines whether the transmission of data appears in two directions simultaneously, only applies when auto-negotiation is
     * disabled.
     */
    fullDuplex?: pulumi.Input<boolean>;
    interfaceEthernetId?: pulumi.Input<string>;
    /**
     * Layer2 Maximum transmission unit. [See](https://wiki.mikrotik.com/wiki/Maximum_Transmission_Unit_on_RouterBoards).
     */
    l2mtu?: pulumi.Input<number>;
    loopProtect?: pulumi.Input<string>;
    loopProtectDisableTime?: pulumi.Input<string>;
    loopProtectSendInterval?: pulumi.Input<string>;
    /**
     * Media Access Control number of an interface.
     */
    macAddress?: pulumi.Input<string>;
    /**
     * Whether the MDI/X auto cross over cable correction feature is enabled for the port (Hardware specific, e.g. ether1 on
     * RB500 can be set to yes/no. Fixed to 'yes' on other hardware.)
     */
    mdixEnable?: pulumi.Input<boolean>;
    /**
     * Layer3 Maximum transmission unit
     */
    mtu?: pulumi.Input<number>;
    /**
     * Name of the ethernet interface.
     */
    name?: pulumi.Input<string>;
    /**
     * An option that enables LLDP for managing devices.
     */
    poeLldpEnabled?: pulumi.Input<boolean>;
    /**
     * PoE settings: (https://wiki.mikrotik.com/wiki/Manual:PoE-Out)
     */
    poeOut?: pulumi.Input<string>;
    /**
     * PoE settings: (https://wiki.mikrotik.com/wiki/Manual:PoE-Out)
     */
    poePriority?: pulumi.Input<number>;
    /**
     * An option that allows us to manually control the voltage outputs on the PoE port.
     */
    poeVoltage?: pulumi.Input<string>;
    /**
     * An options that disables PoE-Out power for 5s between the specified intervals.
     */
    powerCycleInterval?: pulumi.Input<string>;
    /**
     * An address to monitor.
     */
    powerCyclePingAddress?: pulumi.Input<string>;
    /**
     * An option that enables ping watchdog of power cycles on the port if a host does not respond to ICMP or MAC-Telnet
     * packets.
     */
    powerCyclePingEnabled?: pulumi.Input<boolean>;
    /**
     * If the host does not respond over the specified period, the PoE-Out port is switched off for 5s.
     */
    powerCyclePingTimeout?: pulumi.Input<string>;
    /**
     * When set to on, the port will process received pause frames and suspend transmission if required. auto is the same as on
     * except when auto-negotiation=yes flow control status is resolved by taking into account what other end advertises.
     */
    rxFlowControl?: pulumi.Input<string>;
    /**
     * An option to ignore RX LOS (Loss of Signal) status of the SFP module.
     */
    sfpIgnoreRxLos?: pulumi.Input<boolean>;
    /**
     * Allows to control rate select pin for SFP ports. Values: high | low
     */
    sfpRateSelect?: pulumi.Input<string>;
    /**
     * The temperature in Celsius at which the interface will be temporarily turned off due to too high detected SFP module
     * temperature (introduced v6.48).The default value for SFP/SFP+/SFP28 interfaces is 95, and for QSFP+/QSFP28 interfaces 80
     * (introduced v7.6).
     */
    sfpShutdownTemperature?: pulumi.Input<number>;
    /**
     * Sets interface data transmission speed which takes effect only when ```auto_negotiation``` is disabled.
     */
    speed?: pulumi.Input<string>;
    /**
     * When set to on, the port will generate pause frames to the upstream device to temporarily stop the packet transmission.
     * Pause frames are only generated when some routers output interface is congested and packets cannot be transmitted
     * anymore. Auto is the same as on except when auto-negotiation=yes flow control status is resolved by taking into account
     * what other end advertises.
     */
    txFlowControl?: pulumi.Input<string>;
}
